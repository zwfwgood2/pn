## 1. 系统概述

省级节点系统是连接市级节点与全国节点的中间层，负责数据转发、协议转换、流程编排和数据可靠性保障。系统采用流程引擎驱动的架构，支持灵活的接口编排和配置化的节点管理。

## 2. 系统架构

### 2.1 分层架构

系统采用分层架构设计，主要包括以下几层：

1. **接入层**：处理来自市级节点的请求，进行身份验证和权限控制
2. **流程引擎层**：负责流程的定义、执行和监控
3. **节点层**：包含各种原子处理节点，如Token验证、签名验证、全国节点请求等
4. **服务层**：提供业务逻辑处理和数据访问功能
5. **数据层**：负责数据持久化和缓存

![系统架构图](这里应插入架构图)

### 2.2 核心组件

- **流程引擎(ProcessEngine)**：系统的核心组件，负责流程的执行和管理
- **节点(Node)**：执行具体业务逻辑的最小单位
- **上下文(ProcessContext)**：在流程执行过程中传递数据和状态
- **定时任务**：负责定期更新令牌、公钥和恢复失败的流程

## 3. 核心实体类

### 3.1 SysInterfaceDefinitionEntity

接口定义实体类，存储接口的基本信息和处理流程配置。

```java
@Data
@TableName("sys_interface_definition")
public class SysInterfaceDefinitionEntity {
    @TableId(type = IdType.ASSIGN_ID)
    private Long id;
    private String interfaceCode;        // 接口代码
    private String interfaceName;        // 接口名称
    private Integer interfaceType;       // 0:查询接口, 1:写入接口
    private String requestMethod;        // GET, POST, PUT, DELETE等
    private String requestPath;          // 请求路径
    private String processCode;          // 关联的流程定义代码
    private Integer status;              // 0:禁用, 1:启用
    private Date createTime;
    private Date updateTime;
    private String description;          // 接口描述
}
```

### 3.2 SysProcessNodeConfigEntity

流程节点配置实体类，存储流程中每个节点的配置信息。

```java
@Data
@TableName("sys_process_node_config")
public class SysProcessNodeConfigEntity {
    @TableId(type = IdType.ASSIGN_ID)
    private Long id;
    private String processCode;        // 流程代码
    private String nodeId;            // 节点ID
    private String nodeName;          // 节点名称
    private Integer nodeOrder;        // 节点顺序
    private String retryConfig;       // 重试配置，JSON格式
    private Boolean asyncExecution = false; // 是否异步执行
    private String nodeConfig;        // 节点配置参数，JSON格式
    private Integer status;           // 0:禁用, 1:启用
    private Date createTime;
    private Date updateTime;
}
```

### 3.3 SysProcessExecutionRecordEntity

流程执行记录实体类，存储流程执行的历史记录和上下文信息。

```java
@Data
@TableName("sys_process_execution_record")
public class SysProcessExecutionRecordEntity {
    @TableId(type = IdType.ASSIGN_ID)
    private Long id;
    private String executionId;         // 执行ID
    private String requestId;           // 请求ID
    private String processCode;         // 流程代码
    private String interfaceCode;       // 接口代码
    private String appKey;              // 应用密钥
    private Date startTime;             // 开始时间
    private Date endTime;               // 结束时间
    private Integer status;             // 0:初始, 1:执行中, 2:成功, 3:失败, 4:需要重试
    private String errorMessage;        // 错误信息
    private Integer retryCount = 0;     // 重试次数
    private Integer maxRetryCount = 3;  // 最大重试次数
    private String currentNodeId;       // 当前节点ID
    private String executionContext;    // 执行上下文，JSON格式，用于重放
    private Date updateTime;
}
```

### 3.4 SysProcessDefinitionEntity

流程定义实体类，存储接口处理流程的定义信息。

```java
@Data
@TableName("sys_process_definition")
public class SysProcessDefinitionEntity {
    @TableId(type = IdType.ASSIGN_ID)
    private Long id;
    private String processCode;         // 流程代码
    private String processName;         // 流程名称
    private String interfaceCode;       // 接口代码
    private String description;         // 描述
    private Integer status;             // 0:禁用, 1:启用
    private Date createTime;
    private Date updateTime;
}
```

### 3.5 SysAccessOrganizationEntity

接入机构实体类，存储接入机构的信息，合并了原User和Organization表的功能。

```java
@Data
@TableName("sys_access_organization")
public class SysAccessOrganizationEntity {
    @TableId(type = IdType.ASSIGN_ID)
    private Long id;
    private String orgName;             // 机构名称
    private String orgCode;             // 机构代码
    private String username;            // 用户名（登录账号）
    private String password;            // 密码（加密存储）
    private String appKey;              // 应用密钥
    private String publicKey;           // 公钥
    private String privateKey;          // 私钥（加密存储）
    private Integer status;             // 0-禁用，1-启用
    private Date createTime;
    private Date updateTime;
    private Date lastLoginTime;         // 最后登录时间
    private Integer isAdmin;            // 0-否，1-是
    private Integer structureType;      // 0-省级节点，1-市级节点，2-其他
    private String contactPerson;       // 联系人
    private String contactPhone;        // 联系电话
    private String description;         // 描述
}
```

### 3.6 SysAuthorizationLetterEntity

授权书实体类，存储授权书相关信息。

```java
@Data
@TableName("sys_authorization_letter")
public class SysAuthorizationLetterEntity {
    @TableId(type = IdType.ASSIGN_ID)
    private Long id;
    private String authIdentifier;      // 授权书标识字符串
    private String letterName;          // 授权书名称
    private Long authOrgId;             // 授权机构ID
    private String authOrgName;         // 授权机构名称
    private Date startTime;             // 授权开始时间
    private Date endTime;               // 授权结束时间
    private Integer status;             // 0-无效，1-有效
    private String description;         // 描述
    private Date createTime;
    private Date updateTime;
}
```

## 4. 数据库设计

### 4.1 表结构

#### 4.1.1 sys_interface_definition（接口定义表）

```sql
CREATE TABLE `sys_interface_definition` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `interface_code` varchar(50) NOT NULL COMMENT '接口代码',
  `interface_name` varchar(100) NOT NULL COMMENT '接口名称',
  `interface_type` tinyint(4) NOT NULL DEFAULT '0' COMMENT '接口类型：0-查询接口，1-写入接口',
  `request_method` varchar(20) NOT NULL DEFAULT 'POST' COMMENT '请求方法：GET, POST, PUT, DELETE等',
  `request_path` varchar(200) NOT NULL COMMENT '请求路径',
  `process_code` varchar(50) NOT NULL COMMENT '关联的流程定义代码',
  `status` tinyint(4) NOT NULL DEFAULT '1' COMMENT '状态：0-禁用，1-启用',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `description` varchar(255) DEFAULT NULL COMMENT '描述',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_interface_code` (`interface_code`),
  UNIQUE KEY `uk_request_path` (`request_path`),
  KEY `idx_interface_type` (`interface_type`),
  KEY `idx_status` (`status`),
  KEY `idx_process_code` (`process_code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='接口定义表';
```

#### 4.1.2 sys_process_node_config（流程节点配置表）

```sql
CREATE TABLE `sys_process_node_config` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `process_code` varchar(50) NOT NULL COMMENT '流程代码（关联sys_process_definition表）',
  `node_id` varchar(50) NOT NULL COMMENT '节点ID',
  `node_name` varchar(100) NOT NULL COMMENT '节点名称',
  `node_order` int(11) NOT NULL COMMENT '节点顺序',
  `retry_config` text COMMENT '重试配置（JSON格式）',
  `async_execution` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否异步执行：0-否，1-是',
  `node_config` text COMMENT '节点配置参数（JSON格式）',
  `status` tinyint(4) NOT NULL DEFAULT '1' COMMENT '状态：0-禁用，1-启用',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_process_code_node_id` (`process_code`,`node_id`),
  KEY `idx_process_code` (`process_code`),
  KEY `idx_status` (`status`),
  KEY `idx_node_order` (`node_order`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='流程节点配置表';
```

#### 4.1.3 sys_process_execution_record（流程执行记录表）

```sql
CREATE TABLE `sys_process_execution_record` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `execution_id` varchar(100) NOT NULL COMMENT '执行ID',
  `request_id` varchar(100) NOT NULL COMMENT '请求ID',
  `process_code` varchar(50) NOT NULL COMMENT '流程代码（关联sys_process_definition表）',
  `interface_code` varchar(50) NOT NULL COMMENT '接口代码（关联sys_interface_definition表）',
  `app_key` varchar(100) NOT NULL COMMENT '应用密钥（关联sys_access_organization表）',
  `start_time` datetime NOT NULL COMMENT '开始时间',
  `end_time` datetime DEFAULT NULL COMMENT '结束时间',
  `status` tinyint(4) NOT NULL DEFAULT '0' COMMENT '状态：0-初始，1-执行中，2-成功，3-失败，4-需要重试',
  `error_message` text COMMENT '错误信息',
  `retry_count` int(11) NOT NULL DEFAULT '0' COMMENT '重试次数',
  `max_retry_count` int(11) NOT NULL DEFAULT '3' COMMENT '最大重试次数',
  `current_node_id` varchar(50) DEFAULT NULL COMMENT '当前节点ID',
  `execution_context` longtext COMMENT '执行上下文，JSON格式，用于重放',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_execution_id` (`execution_id`),
  KEY `idx_request_id` (`request_id`),
  KEY `idx_process_code` (`process_code`),
  KEY `idx_interface_code` (`interface_code`),
  KEY `idx_app_key` (`app_key`),
  KEY `idx_status` (`status`),
  KEY `idx_start_time` (`start_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='流程执行记录表';
```

#### 4.1.4 sys_process_definition（流程定义表）

```sql
CREATE TABLE `sys_process_definition` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `process_code` varchar(50) NOT NULL COMMENT '流程代码',
  `process_name` varchar(100) NOT NULL COMMENT '流程名称',
  `interface_code` varchar(50) DEFAULT NULL COMMENT '接口代码（关联sys_interface_definition表）',
  `description` varchar(255) DEFAULT NULL COMMENT '描述',
  `status` tinyint(4) NOT NULL DEFAULT '1' COMMENT '状态：0-禁用，1-启用',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_process_code` (`process_code`),
  KEY `idx_interface_code` (`interface_code`),
  KEY `idx_status` (`status`),
  KEY `idx_create_time` (`create_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='流程定义表';
```

#### 4.1.5 sys_access_organization（接入机构表）

```sql
CREATE TABLE `sys_access_organization` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `org_name` varchar(100) NOT NULL COMMENT '机构名称',
  `org_code` varchar(50) NOT NULL COMMENT '机构代码',
  `username` varchar(50) NOT NULL COMMENT '用户名（登录账号）',
  `password` varchar(255) NOT NULL COMMENT '密码（加密存储）',
  `app_key` varchar(100) NOT NULL COMMENT '应用密钥',
  `public_key` text COMMENT '公钥',
  `private_key` text COMMENT '私钥（加密存储）',
  `status` tinyint(4) NOT NULL DEFAULT '1' COMMENT '状态：0-禁用，1-启用',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `last_login_time` datetime DEFAULT NULL COMMENT '最后登录时间',
  `is_admin` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否管理员：0-否，1-是',
  `structure_type` tinyint(4) NOT NULL DEFAULT '1' COMMENT '结构类型：0-省级节点，1-市级节点，2-其他',
  `contact_person` varchar(50) DEFAULT NULL COMMENT '联系人',
  `contact_phone` varchar(20) DEFAULT NULL COMMENT '联系电话',
  `description` varchar(255) DEFAULT NULL COMMENT '描述',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_org_code` (`org_code`),
  UNIQUE KEY `uk_username` (`username`),
  UNIQUE KEY `uk_app_key` (`app_key`),
  KEY `idx_status` (`status`),
  KEY `idx_create_time` (`create_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='接入机构表';
```

#### 4.1.6 sys_request_log（请求日志表）

```sql
CREATE TABLE `sys_request_log` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `request_id` varchar(100) NOT NULL COMMENT '请求ID',
  `interface_code` varchar(50) NOT NULL COMMENT '接口代码',
  `app_key` varchar(100) NOT NULL COMMENT '应用密钥（关联sys_access_organization表）',
  `request_time` datetime NOT NULL COMMENT '请求时间',
  `response_time` datetime DEFAULT NULL COMMENT '响应时间',
  `request_params` text COMMENT '请求参数（JSON格式）',
  `response_result` text COMMENT '响应结果（JSON格式）',
  `status` tinyint(4) NOT NULL DEFAULT '0' COMMENT '状态：0-失败，1-成功',
  `error_message` text COMMENT '错误信息',
  `request_ip` varchar(50) DEFAULT NULL COMMENT '请求IP',
  `processing_time` bigint(20) DEFAULT NULL COMMENT '处理耗时（毫秒）',
  PRIMARY KEY (`id`),
  KEY `idx_request_id` (`request_id`),
  KEY `idx_interface_code` (`interface_code`),
  KEY `idx_app_key` (`app_key`),
  KEY `idx_request_time` (`request_time`),
  KEY `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='请求日志表';
```

#### 4.1.7 sys_authorization_letter（授权书表）

```sql
CREATE TABLE `sys_authorization_letter` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `auth_identifier` varchar(100) NOT NULL COMMENT '授权书标识字符串',
  `letter_name` varchar(100) NOT NULL COMMENT '授权书名称',
  `auth_org_id` bigint(20) NOT NULL COMMENT '授权机构ID（关联sys_access_organization表）',
  `auth_org_name` varchar(100) NOT NULL COMMENT '授权机构名称',
  `start_time` datetime NOT NULL COMMENT '授权开始时间',
  `end_time` datetime NOT NULL COMMENT '授权结束时间',
  `status` tinyint(4) NOT NULL DEFAULT '1' COMMENT '状态：0-无效，1-有效',
  `description` varchar(255) DEFAULT NULL COMMENT '描述',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_auth_identifier` (`auth_identifier`),
  KEY `idx_auth_org_id` (`auth_org_id`),
  KEY `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='授权书表';
```

## 5. 流程引擎实现

### 5.1 Node接口

节点是流程引擎的基本执行单元，所有具体节点都需要实现此接口。

```java
public interface Node {
    String inParamName="inParamName";
    String outParamName="outParamName";
    String inParamType="inParamType";
    String outParamType="outParamType";

    String side="side";
    String requestParams="requestParams";
    String NodeConfig="NodeConfig";

    boolean execute(ProcessContext context);
    String getNodeId();
    String getNodeName();
}
```

### 5.2 ProcessContext类

上下文类用于在流程执行过程中传递和存储数据。

```java
@Data
public class ProcessContext {
    // 请求ID
    private String requestId;
    // 接口代码
    private String interfaceCode;
    // AppKey
    private String appKey;
    // 请求参数
    private Map<String, Object> requestParams = new HashMap<>();
    // 响应结果
    private Object responseData;
    // 处理状态
    private boolean success = true;
    // 错误信息
    private String errorMessage;
    // 错误码
    private String errorCode;
    // 中间数据存储
    private Map<String, Object> attributes = new HashMap<>();

    // 其他方法...
}
```

### 5.3 ProcessEngine类

流程引擎的核心实现，负责流程的执行、异步处理和重试逻辑。

```java
@Slf4j
@Component
public class ProcessEngine {
    @Autowired
    private SysProcessNodeConfigService processNodeConfigService;
    @Autowired
    private SysProcessExecutionRecordService processExecutionRecordService;
    @Autowired
    private Map<String, Node> nodeMap;

    // 异步执行线程池
    private final ExecutorService asyncExecutor = new ThreadPoolExecutor(
            10, // 核心线程数
            50, // 最大线程数
            60L, TimeUnit.SECONDS, // 空闲线程存活时间
            new LinkedBlockingQueue<>(1000), // 工作队列
            new ThreadPoolExecutor.CallerRunsPolicy() // 拒绝策略
    );

    // 执行流程方法
    public Result<JSONObject> executeProcess(String processCode, ProcessContext context) {
        // 实现流程执行逻辑
    }

    // 其他方法...
}
```

## 6. 原子节点配置与实现

### 6.1 节点配置示例

节点配置使用JSON格式，主要包含输入输出参数定义和节点特定配置。以下是各种原子节点的配置示例：

#### 6.1.1 通用节点配置格式

每个节点配置分为两部分：通用的重试配置 `retry_config` 和节点特定配置 `node_config`。

**retry_config 格式：**
```json
{
  "maxRetryCount": 3,       // 最大重试次数
  "initialDelay": 1000,     // 初始延迟（毫秒）
  "multiplier": 2.0         // 延迟倍数（指数退避）
}
```

**node_config 格式：**
```json
{
  "inParamName": "requestParams",   // 输入参数名称
  "inParamType": "map",             // 输入参数类型（支持：array,map,jsonObject,string）
  "outParamName": "outputData",     // 输出参数名称
  "outParamType": "jsonObject",     // 输出参数类型（支持：array,map,jsonObject,string）
  // 其他节点特定配置...
}
```

#### 6.1.2 Token验证节点配置

```json
{
  "retry_config": {
    "maxRetryCount": 3,
    "initialDelay": 1000,
    "multiplier": 2.0
  },
  "node_config": {
    "inParamName": "requestParams",
    "inParamType": "map",
    "outParamName": "tokenValidationResult",
    "outParamType": "boolean"
  }
}
```

#### 6.1.3 验签节点配置

```json
{
  "retry_config": {
    "maxRetryCount": 3,
    "initialDelay": 1000,
    "multiplier": 2.0
  },
  "node_config": {
    "inParamName": "requestParams",
    "inParamType": "map",
    "outParamName": "signatureValidationResult",
    "outParamType": "boolean",
    "side": "city"  // 可选值：national（全国节点）、provincial（省级节点）、city（市级节点）
  }
}
```

#### 6.1.4 全国节点请求节点配置

```json
{
  "retry_config": {
    "maxRetryCount": 5,
    "initialDelay": 2000,
    "multiplier": 1.5
  },
  "node_config": {
    "inParamName": "requestParams",
    "inParamType": "map",
    "outParamName": "nationalNodeResponse",
    "outParamType": "jsonObject"
  }
}
```
#### 6.1.5 参数验证节点配置

参数验证节点支持多层级嵌套验证，适用于复杂的数据结构验证场景。以下是该节点的配置示例：

```json
{
  "validateRules": [
    {
      "paramName": "userInfo",
      "rules": [
        {
          "type": "required",
          "config": true
        },
        {
          "type": "dataType",
          "config": "object",
          "nestedRules": [
            {
              "paramName": "name",
              "rules": [
                {
                  "type": "required",
                  "config": true
                },
                {
                  "type": "stringLength",
                  "config": {
                    "minLength": 2,
                    "maxLength": 20
                  }
                }
              ]
            },
            {
              "paramName": "age",
              "rules": [
                {
                  "type": "required",
                  "config": true
                },
                {
                  "type": "dataType",
                  "config": "integer"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "paramName": "addresses",
      "rules": [
        {
          "type": "required",
          "config": true
        },
        {
          "type": "dataType",
          "config": "array",
          "nestedRules": [
            {
              "rules": [
                {
                  "type": "dataType",
                  "config": "object",
                  "nestedRules": [
                    {
                      "paramName": "city",
                      "rules": [
                        {
                          "type": "required",
                          "config": true
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "paramName": "jsonData",
      "rules": [
        {
          "type": "dataType",
          "config": "json",
          "nestedRules": [
            {
              "paramName": "settings.theme",
              "rules": [
                {
                  "type": "required",
                  "config": true
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}
```

#### 6.1.6 配置说明

1. **paramName**: 参数路径，支持点号分隔的嵌套路径，如 "userInfo.address.city"

2. **rules**: 验证规则列表，每个规则包含：
   - **type**: 验证器类型，支持 required、dataType、stringLength、regex 等
   - **config**: 验证器配置参数
   - **nestedRules**: 嵌套验证规则（仅在 dataType 验证器中使用）

3. **支持的参数类型**:
   - **string**: 字符串类型
   - **integer/int/long/double/float/boolean**: 基本数据类型
   - **array/iterable**: 数组或集合类型
   - **object/map**: 对象或映射类型
   - **json**: JSON字符串类型

4. **嵌套验证**: 通过 dataType 验证器的 nestedRules 属性实现多层级验证
   - 对于 array/iterable 类型，nestedRules 会应用到数组中的每个元素
   - 对于 object/map 类型，nestedRules 可以指定子字段的验证规则
   - 对于 json 类型，会先解析JSON字符串，然后对解析后的对象进行验证


#### 6.1.7 签名节点配置

```json
{
  "retry_config": {
    "maxRetryCount": 3,
    "initialDelay": 1000,
    "multiplier": 2.0
  },
  "node_config": {
    "inParamName": "responseData",
    "inParamType": "map",
    "outParamName": "signedData",
    "outParamType": "map",
    "side": "provincial", // 可选值：national（全国节点）、provincial（省级节点）、city（市级节点）
     "dataSource":"requestData" // 待签名数据参数名称;必填，可选值：requestData（请求数据源）、data（响应数据源）
  }
}
```

#### 6.1.8 授权书校验节点配置

```json
{
  "retry_config": {
    "maxRetryCount": 3,
    "initialDelay": 1000,
    "multiplier": 2.0
  },
  "node_config": {
    "inParamName": "requestParams",
    "inParamType": "map",
    "outParamName": "authorizationResult",
    "outParamType": "boolean"
  }
}
```

### 6.2 全国节点请求节点实现

以下是全国节点请求节点的完整实现：

```java
@Slf4j
@Component("nationalNodeRequestNode")
public class NationalNodeRequestNode implements Node {
    @Autowired
    private NationalNodeConfig nationalNodeConfig;

    private static final String NODE_ID = "nationalNodeRequestNode";
    private static final String NODE_NAME = "全国节点请求节点";

    @Override
    public String getNodeId() {
        return NODE_ID;
    }

    @Override
    public String getNodeName() {
        return NODE_NAME;
    }
}
    @Override
    public boolean execute(ProcessContext context) {
        log.info("执行全国节点请求节点: {}", context.getRequestId());
        
        try {
            // 1. 获取请求参数和接口信息
            String interfaceCode = context.getInterfaceCode();
            Map<String, Object> requestParams = context.getAttribute(Node.inParamName);
            
            // 2. 构建全国节点请求URL
            String requestUrl = nationalNodeConfig.getNationalNodeUrl() + "/" + interfaceCode;
            
            // 3. 构建请求参数
            JSONObject requestBody = new JSONObject();
            requestBody.putAll(requestParams);
            
            // 4. 发送请求到全国节点
            String response = sendRequest(requestUrl, requestBody.toJSONString());
            
            // 5. 解析响应结果
            if (response == null || response.isEmpty()) {
                context.markFailure(ResultCode.NATIONAL_NODE_ERROR.getCode(), "全国节点返回空结果");
                log.error("全国节点返回空结果: {}", requestUrl);
                return false;
            }
            
            // 6. 将全国节点返回结果保存到上下文中
            context.setAttribute(Node.outParamName, response);
            
            log.info("全国节点请求成功: {}, 响应: {}", requestUrl, response);
            return true;
        } catch (Exception e) {
            log.error("全国节点请求节点执行异常: {}", e.getMessage(), e);
            context.markFailure(ResultCode.NATIONAL_NODE_ERROR.getCode(), "全国节点请求异常");
            return false;
        }
    }

    /**
     * 发送HTTP请求到全国节点
     * @param url 请求URL
     * @param requestBody 请求体
     * @return 响应结果
     */
    private String sendRequest(String url, String requestBody) {
        CloseableHttpClient httpClient = HttpClients.createDefault();
        HttpPost httpPost = new HttpPost(url);
        httpPost.setHeader("Content-Type", "application/json; charset=UTF-8");
        httpPost.setEntity(new StringEntity(requestBody, StandardCharsets.UTF_8));
        try {
            log.info("发送请求到全国节点,请求体: {}", requestBody);
            CloseableHttpResponse response = httpClient.execute(httpPost);
            int statusCode = response.getStatusLine().getStatusCode();

            if (statusCode == 200) {
                String responseBody = EntityUtils.toString(response.getEntity(), StandardCharsets.UTF_8);
                response.close();
                httpClient.close();
                return responseBody;
            } else {
                log.warn("全国节点请求失败，状态码: {}", statusCode);
                EntityUtils.consume(response.getEntity());
                response.close();
            }
        } catch (IOException e) {
            log.warn("全国节点请求异常: {}", e.getMessage());
            throw new RuntimeException("全国节点请求失败！");
        }
        return null;
    }

    @Override
    public String getNodeId() {
        return NODE_ID;
    }

    @Override
    public String getNodeName() {
        return NODE_NAME;
    }
```

### 6.3 参数验证节点实现

```java
@Component("enhancedParamValidateNode")
public class EnhancedParamValidateNode implements Node {

    @Autowired
    private ParamValidatorFactory validatorFactory;

    private static final String NODE_ID = "enhancedParamValidateNode";
    private static final String NODE_NAME = "增强型参数验证节点";

    @Override
    public boolean execute(ProcessContext context) {
        // 节点实现代码（略）
        return true;
    }

    @Override
    public String getNodeId() {
        return NODE_ID;
    }

    @Override
    public String getNodeName() {
        return NODE_NAME;
    }
}
```
### 6.4 Token验证节点实现

```java
@Slf4j
@Component("tokenValidateNode")
public class TokenValidateNode implements Node {

    @Autowired
    private SysAccessOrganizationService sysAccessOrganizationService;
    
    @Autowired
    private CacheService cacheService;

    private static final String NODE_ID = "tokenValidateNode";
    private static final String NODE_NAME = "Token验证节点";

    @Override
    public boolean execute(ProcessContext context) {
        log.info("执行Token验证节点: {}", context.getRequestId());
        
        try {
            // 1. 获取Token
            Map<String, Object> requestParams = context.getAttribute(Node.inParamName);
            String token = (String) requestParams.get("token");
            String appKey = context.getAppKey();
            
            if (token == null || token.isEmpty()) {
                context.markFailure(ResultCode.TOKEN_ERROR.getCode(), "Token不能为空");
                log.error("Token为空: {}", context.getRequestId());
                return false;
            }
            
            // 2. 验证Token
            String cacheToken = cacheService.get("token:" + appKey);
            if (cacheToken == null || !cacheToken.equals(token)) {
                context.markFailure(ResultCode.TOKEN_ERROR.getCode(), "Token无效或已过期");
                log.error("Token验证失败: {}, appKey: {}", context.getRequestId(), appKey);
                return false;
            }
            
            // 3. 获取机构信息
            SysAccessOrganizationEntity organization = sysAccessOrganizationService.findByAppKey(appKey);
            if (organization == null || organization.getStatus() == 0) {
                context.markFailure(ResultCode.AUTH_ERROR.getCode(), "机构未注册或已禁用");
                log.error("机构验证失败: {}, appKey: {}", context.getRequestId(), appKey);
                return false;
            }
            
            // 4. 保存验证结果
            context.setAttribute(Node.outParamName, true);
            context.setAttribute("organizationInfo", organization);
            
            log.info("Token验证成功: {}, appKey: {}", context.getRequestId(), appKey);
            return true;
        } catch (Exception e) {
            log.error("Token验证节点执行异常: {}", e.getMessage(), e);
            context.markFailure(ResultCode.SYSTEM_ERROR.getCode(), "Token验证异常");
            return false;
        }
    }

    @Override
    public String getNodeId() {
        return NODE_ID;
    }

    @Override
    public String getNodeName() {
        return NODE_NAME;
    }
}
```

### 6.5 验签节点实现

```java
@Slf4j
@Component("verifyNode")
public class VerifyNode implements Node {

    @Autowired
    private SysAccessOrganizationService sysAccessOrganizationService;
    @Autowired
    private NationalNodeConfig nationalNodeConfig;

    private static final String NODE_ID = "verifyNode";
    private static final String NODE_NAME = "验签节点";

    @Override
    public boolean execute(ProcessContext context) {
        log.info("执行签名验证节点: {}", context.getRequestId());
        
        try {
            // 1. 获取请求参数和签名
            Map<String, Object> requestParams = context.getAttribute(Node.inParamName);
            String signature = (String) requestParams.get("signature");
            String appKey = context.getAppKey();
            
            // 2. 获取节点配置中的side参数，默认为city
            Map<String, Object> nodeConfig = context.getAttribute(Node.NodeConfig);
            String side = "city";
            if (nodeConfig != null && nodeConfig.containsKey(Node.side)) {
                side = (String) nodeConfig.get(Node.side);
            }
            
            // 3. 获取对应节点的公钥
            String publicKey = null;
            if ("city".equals(side)) {
                // 获取市级节点公钥
                SysAccessOrganizationEntity organization = sysAccessOrganizationService.findByAppKey(appKey);
                if (organization == null) {
                    context.markFailure(ResultCode.AUTH_ERROR.getCode(), "机构未注册");
                    return false;
                }
                publicKey = organization.getPublicKey();
            } else if ("national".equals(side)) {
                // 获取全国节点公钥
                publicKey = nationalNodeConfig.getPublicKey();
            }
            
            if (publicKey == null || publicKey.isEmpty()) {
                context.markFailure(ResultCode.SYSTEM_ERROR.getCode(), "无法获取公钥");
                return false;
            }
            
            // 4. 验证签名
            boolean verified = verifySignature(requestParams, signature, publicKey);
            
            if (!verified) {
                context.markFailure(ResultCode.SIGNATURE_ERROR.getCode(), "签名验证失败");
                log.error("签名验证失败: {}, appKey: {}", context.getRequestId(), appKey);
                return false;
            }
            
            // 5. 保存验证结果
            context.setAttribute(Node.outParamName, true);
            
            log.info("签名验证成功: {}, side: {}", context.getRequestId(), side);
            return true;
        } catch (Exception e) {
            log.error("签名验证节点执行异常: {}", e.getMessage(), e);
            context.markFailure(ResultCode.SYSTEM_ERROR.getCode(), "签名验证异常");
            return false;
        }
    }

    /**
     * 验证签名
     */
    private boolean verifySignature(Map<String, Object> params, String signature, String publicKey) {
        // 签名验证逻辑实现
        // ...
        return true; // 简化返回
    }

    @Override
    public String getNodeId() {
        return NODE_ID;
    }

    @Override
    public String getNodeName() {
        return NODE_NAME;
    }
}
```
### 6.6 签名节点实现

```java
@@Component("signatureNode")
public class SignatureNode implements Node {

    @Autowired
    private SysAccessOrganizationService sysAccessOrganizationService;
    @Autowired
    private NationalNodeConfig mationalNodeConfig;
    private static final String NODE_ID = "signatureNode";
    private static final String NODE_NAME = "签名节点";

    @Override
    public boolean execute(ProcessContext context) {
        log.info("执行签名节点: {}", context.getRequestId());

        try {
            // 1. 获取AppKey
            String appKey = context.getAppKey();
            // 2. 获取待签名数据（从上下文中获取）
            Map<String, Object> requestParams = context.getAttribute(Node.inParamName);
            if (requestParams == null || requestParams.isEmpty()) {
                context.markFailure(ResultCode.DATA_NOT_FOUND.getCode(), "待签名数据为空");
                return false;
            }
            // 3. 获取机构信息
            SysAccessOrganizationEntity org = sysAccessOrganizationService.selectByAppKey(appKey);
            if (org == null) {
                throw new BusinessException(ResultCode.NOT_FOUND.getCode(), "未找到对应的机构信息: " + appKey);
            }

            String verifyPrivateKey =org.getPrivateKey();
            String encryptPublicKey=requestParams.get("publicKey").toString();
            //根据端点获取解密私钥和验签公钥
            if(side.equals("national")){
                SysAccessOrganizationEntity self = sysAccessOrganizationService.selectByAppKey("self");
                verifyPrivateKey=self.getPrivateKey();
                encryptPublicKey=mationalNodeConfig.getPublicKey();
            }
            // 5. 对数据进行签名
            Map<String,String> signature = SignUtil.signData(requestParams.get("requestData").toString(), encryptPublicKey,verifyPrivateKey);
            Map<String,Object> responseParams = new HashMap<>(6);
            responseParams.putAll(requestParams);
            responseParams.putAll(signature);
            // 6. 将签名结果保存到上下文中
            context.setAttribute(Node.outParamName,responseParams);

            log.info("数据签名成功: {}", context.getRequestId());
            return true;
        } catch (Exception e) {
            log.error("签名节点执行异常: {}", e.getMessage(), e);
            context.markFailure(ResultCode.SYSTEM_ERROR.getCode(), "数据签名异常");
            return false;
        }
    }

    @Override
    public String getNodeId() {
        return NODE_ID;
    }

    @Override
    public String getNodeName() {
        return NODE_NAME;
    }

}
```
### 6.7 参数校验节点实现

```java
@Component("paramValidateNode")
public class ParamValidateNode implements Node {

    @Autowired
    private ParamValidatorFactory validatorFactory;

    private static final String NODE_ID = "paramValidateNode";
    private static final String NODE_NAME = "参数验证节点";

    @Override
    public boolean execute(ProcessContext context) {
        log.info("执行增强型参数验证节点: {}", context.getRequestId());

        try {
            //从节点配置中获取参数校验规则
            Map<String, Object> nodeConfig = context.getAttribute("nodeConfig");
            if (nodeConfig == null || !nodeConfig.containsKey("validateRules")) {
                log.info("未配置参数校验规则，跳过参数校验");
                return true;
            }

            // 解析校验规则
            String validateRulesJson = nodeConfig.get("validateRules").toString();
            JSONArray validateRules = JSON.parseArray(validateRulesJson);

            // 获取请求参数
            Map<String, Object> requestParams = context.getAttribute(Node.inParamName);
            // 执行参数校验
            for (int i = 0; i < validateRules.size(); i++) {
                JSONObject rule = validateRules.getJSONObject(i);
                String paramName = rule.getString("paramName");

                // 获取字段级别的校验规则
                JSONArray fieldRules = rule.getJSONArray("rules");
                if (fieldRules == null || fieldRules.isEmpty()) {
                    continue;
                }

                // 获取参数值
                Object paramValue = requestParams.get(paramName);

                // 对每个字段执行配置的所有校验规则
                for (int j = 0; j < fieldRules.size(); j++) {
                    JSONObject fieldRule = fieldRules.getJSONObject(j);
                    String validatorType = fieldRule.getString("type");
                    Object ruleConfig = fieldRule.get("config");

                    // 获取对应的校验器
                    ParamValidator validator = validatorFactory.getValidator(validatorType);
                    if (validator == null) {
                        log.warn("未找到校验器: {}", validatorType);
                        continue;
                    }

                    // 执行校验
                    boolean isValid = validator.validate(paramValue, ruleConfig);
                    if (!isValid) {
                        // 校验失败，生成错误消息并标记为失败
                        String errorMessage = validator.getErrorMessage(paramName, paramValue, ruleConfig);
                        context.markFailure(ResultCode.PARAM_ERROR.getCode(), errorMessage);
                        log.error("参数校验失败: {}", errorMessage);
                        return false;
                    }
                }
            }

            log.info("参数校验通过: {}", context.getRequestId());
            return true;
        } catch (Exception e) {
            log.error("参数验证节点执行异常: {}", e.getMessage(), e);
            context.markFailure(ResultCode.PARAM_ERROR.getCode(), "参数验证异常: " + e.getMessage());
            return false;
        }
    }

    @Override
    public String getNodeId() {
        return NODE_ID;
    }

    @Override
    public String getNodeName() {
        return NODE_NAME;
    }
}
```

## 7. 数据可靠性设计

### 7.1 节点重试机制

系统支持配置化的节点重试机制，使用指数退避算法计算重试间隔。

```java
private static class RetryConfig {
    private final int maxRetryCount; // 最大重试次数
    private final int initialDelay; // 初始延迟（毫秒）
    private final double multiplier; // 延迟倍数

    // 计算指定重试次数的延迟时间
    public long getDelayMs(int retryCount) {
        return (long) (initialDelay * Math.pow(multiplier, retryCount - 1));
    }

    // 其他方法...
}
```

### 7.2 流程恢复机制

系统通过定时任务定期恢复失败的流程执行。

```java
@XxlJob("processRecoveryJob")
public ReturnT<String> processRecovery(String param) {
    // 查询需要重试的执行记录
    List<SysProcessExecutionRecordEntity> records = processExecutionRecordService.getRetryableExecutionRecords();
    
    // 并发处理每个需要重试的记录
    for (SysProcessExecutionRecordEntity record : records) {
        executorService.submit(() -> {
            try {
                // 使用ProcessEngine重放流程
                Result<?> result = processEngine.replayProcess(record.getExecutionId());
                
                if (result.isSuccess()) {
                    // 流程恢复成功
                } else {
                    // 标记为需要重试，让下一次定时任务继续尝试
                    processExecutionRecordService.markForRetry(record.getExecutionId(), result.getMessage());
                }
            } catch (Exception e) {
                // 异常处理
            }
        });
    }
    
    // 其他逻辑...
}
```

## 8. 接口编排示例

### 8.1 创建接口流程

以一个典型的省级节点转发接口为例，其处理流程如下：

1. 接收市级节点请求
2. 验证Token
3. 验证签名
4. 调用全国节点服务

### 8.2 流程配置

在数据库中配置上述流程的节点信息：

| 节点顺序 | 节点ID | 节点名称 | 异步执行 | 重试配置 | node_config |
|---------|-------|---------|---------|---------|------------|
| 1 | tokenValidateNode | Token验证节点 | 否 | {"maxRetryCount":3,"initialDelay":1000,"multiplier":2.0} | {"inParamName":"requestParams","inParamType":"map","outParamName":"tokenValidationResult","outParamType":"boolean"} |
| 2 | signatureVerifyNode | 签名验证节点 | 否 | {"maxRetryCount":3,"initialDelay":1000,"multiplier":2.0} | {"inParamName":"requestParams","inParamType":"map","outParamName":"signatureValidationResult","outParamType":"boolean","side":"city"} |
| 3 | nationalNodeRequestNode | 全国节点请求节点 | 否 | {"maxRetryCount":5,"initialDelay":2000,"multiplier":1.5} | {"inParamName":"requestParams","inParamType":"map","outParamName":"nationalNodeResponse","outParamType":"jsonObject"} |

## 9. 核心代码示例

### 9.1 MainController

```java
@Slf4j
@RestController
@RequestMapping("/api")
public class MainController {
    @Autowired
    private SysInterfaceDefinitionService sysInterfaceDefinitionService;
    @Autowired
    private ProcessEngine processEngine;

    // 处理所有接口请求
    @RequestMapping(value = "{code}", method = {RequestMethod.GET, RequestMethod.POST, RequestMethod.PUT, RequestMethod.DELETE})
    public Result<JSONObject> handleRequest(MultipartFile file, @PathVariable String code, HttpServletRequest request, @RequestBody(required = false) Map<String, Object> requestBody) {
        // 1. 获取请求URL和请求方法
        String requestURI = request.getRequestURI();
        String requestMethod = request.getMethod();
        // 2. 从URL中提取接口路径
        String contextPath = request.getContextPath();
        String interfacePath = requestURI.substring(contextPath.length());
        
        // 3. 根据请求路径查询接口定义
        SysInterfaceDefinitionEntity interfaceDefinition = sysInterfaceDefinitionService.findByRequestPath(interfacePath);
        
        // 4. 构建处理上下文
        ProcessContext context = buildProcessContext(request, requestBody, interfaceDefinition.getInterfaceCode(), interfaceDefinition);
        
        // 5. 使用流程引擎执行流程
        Result<JSONObject> result = processEngine.executeProcess(interfaceDefinition.getProcessCode(), context);
        
        return result;
    }

    // 其他方法...
}
```

### 9.2 ProcessEngine流程执行

```java
public Result<JSONObject> executeProcess(String processCode, ProcessContext context) {
    // 创建流程执行记录
    SysProcessExecutionRecordEntity executionRecord = processExecutionRecordService.createExecutionRecord(
            processCode,
            context.getInterfaceCode(),
            context.getAppKey(),
            context.getRequestId()
    );

    try {
        // 标记流程开始执行
        processExecutionRecordService.updateExecutionStatus(
                executionRecord.getExecutionId(),
                1, // 执行中
                null
        );

        // 查询流程节点配置
        List<SysProcessNodeConfigEntity> nodeConfigs = processNodeConfigService.getEnabledNodesByProcessCode(processCode);
        
        // 按顺序执行节点
        for (SysProcessNodeConfigEntity nodeConfig : nodeConfigs) {
            // 执行节点逻辑
            // ...
        }

        // 完成流程执行
        processExecutionRecordService.completeExecution(
                executionRecord.getExecutionId(),
                context.isSuccess() ? 2 : 3, // 2:成功, 3:失败
                context.isSuccess() ? null : context.getErrorMessage()
        );

        return result;
    } catch (Exception e) {
        // 异常处理
    } finally {
        // 记录执行上下文，用于重放
        processExecutionRecordService.recordExecutionContext(
                executionRecord.getExecutionId(),
                context
        );
    }
}
```

## 10. 配置项说明

系统配置主要包括以下几个方面：

### 10.1 全国节点配置

```java
@Setter
@Getter
@Component
public class NationalNodeConfig {
    // 全国节点地址
    @Value("${provincial.node.national-node-url}")
    private String nationalNodeUrl;

    // 全国节点连接超时时间
    @Value("${provincial.node.connect-timeout}")
    private int connectTimeout;

    // 全国节点读取超时时间
    @Value("${provincial.node.read-timeout}")
    private int readTimeout;

    // 全国节点公钥
    private volatile String publicKey;

    // 全国节点令牌
    private volatile String token;

    // 令牌过期时间（秒）
    @Value("${provincial.node.token.expire-time}")
    private int tokenExpireTime;

    // 令牌刷新阈值（秒）
    @Value("${provincial.node.token.refresh-threshold}")
    private int tokenRefreshThreshold;
}
```

## 11. 部署指南

### 11.1 环境要求

- JDK 1.8+ 
- MySQL 5.7+ 
- Redis 5.0+ 
- XXL-Job 2.3.0+ 

### 11.2 部署步骤

1. 准备数据库并导入表结构
2. 配置应用参数（数据库连接、Redis连接、XXL-Job配置等）
3. 构建并部署应用
4. 配置流程和节点信息
5. 启动应用和相关服务

## 12. 扩展指南

### 12.1 添加新节点

1. 创建实现Node接口的新节点类
2. 使用@Component注解注册节点（指定节点ID）
3. 在数据库中配置节点的使用流程

### 12.2 自定义流程

通过配置数据库中的流程节点信息，可以灵活组合不同的节点来创建新的流程，无需修改代码。

## 13. 监控与维护

系统提供了流程执行记录和错误日志，方便监控和排查问题。定时任务会自动尝试恢复失败的流程，确保数据的可靠性。

---
版本: 1.2
更新时间: 2025-09-19