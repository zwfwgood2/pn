# 省级节点系统设计文档

## 1. 系统概述

省级节点系统是连接市级节点与全国节点的中间层，负责数据转发、协议转换、流程编排和数据可靠性保障。系统采用流程引擎驱动的架构，支持灵活的接口编排和配置化的节点管理。

## 2. 系统架构

### 2.1 分层架构

系统采用分层架构设计，主要包括以下几层：

1. **接入层**：处理来自市级节点的请求，进行身份验证和权限控制
2. **流程引擎层**：负责流程的定义、执行和监控
3. **节点层**：包含各种原子处理节点，如Token验证、签名验证、全国节点请求等
4. **服务层**：提供业务逻辑处理和数据访问功能
5. **数据层**：负责数据持久化和缓存

![系统架构图](这里应插入架构图)

### 2.2 核心组件

- **流程引擎(ProcessEngine)**：系统的核心组件，负责流程的执行和管理
- **节点(Node)**：执行具体业务逻辑的最小单位
- **上下文(ProcessContext)**：在流程执行过程中传递数据和状态
- **定时任务**：负责定期更新令牌、公钥和恢复失败的流程

## 3. 核心实体类

### 3.1 SysInterfaceDefinitionEntity

接口定义实体类，存储接口的基本信息和处理流程配置。

### 3.2 SysProcessNodeConfigEntity

流程节点配置实体类，存储流程中每个节点的配置信息。

```java
@Data
@TableName("sys_process_node_config")
public class SysProcessNodeConfigEntity {
    @TableId(type = IdType.ASSIGN_ID)
    private Long id;
    private String processCode;        // 流程代码
    private String nodeId;            // 节点ID
    private String nodeName;          // 节点名称
    private Integer nodeOrder;        // 节点顺序
    private String retryConfig;       // 重试配置，JSON格式
    private Boolean asyncExecution = false; // 是否异步执行
    private String nodeConfig;        // 节点配置参数，JSON格式
    private Integer status;           // 0:禁用, 1:启用
    private Date createTime;
    private Date updateTime;
}
```

### 3.3 SysProcessExecutionRecordEntity

流程执行记录实体类，存储流程执行的历史记录和上下文信息。

## 4. 数据库设计

### 4.1 表结构

#### 4.1.1 sys_interface_definition（接口定义表）

```sql
CREATE TABLE `sys_interface_definition` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `interface_code` varchar(50) NOT NULL COMMENT '接口代码',
  `interface_name` varchar(100) NOT NULL COMMENT '接口名称',
  `request_path` varchar(200) NOT NULL COMMENT '请求路径',
  `request_method` varchar(20) NOT NULL COMMENT '请求方法',
  `process_code` varchar(50) NOT NULL COMMENT '关联的流程代码',
  `status` tinyint(4) DEFAULT '1' COMMENT '状态(0:禁用,1:启用)',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_interface_code` (`interface_code`),
  UNIQUE KEY `uk_request_path` (`request_path`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='接口定义表';
```

#### 4.1.2 sys_process_node_config（流程节点配置表）

```sql
CREATE TABLE `sys_process_node_config` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `process_code` varchar(50) NOT NULL COMMENT '流程代码',
  `node_id` varchar(50) NOT NULL COMMENT '节点ID',
  `node_name` varchar(100) NOT NULL COMMENT '节点名称',
  `node_order` int(11) NOT NULL COMMENT '节点顺序',
  `retry_config` text COMMENT '重试配置(JSON格式)',
  `async_execution` tinyint(1) DEFAULT '0' COMMENT '是否异步执行(0:否,1:是)',
  `node_config` text COMMENT '节点配置参数(JSON格式)',
  `status` tinyint(4) DEFAULT '1' COMMENT '状态(0:禁用,1:启用)',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  KEY `idx_process_code` (`process_code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='流程节点配置表';
```

#### 4.1.3 sys_process_execution_record（流程执行记录表）

```sql
CREATE TABLE `sys_process_execution_record` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `execution_id` varchar(50) NOT NULL COMMENT '执行ID',
  `process_code` varchar(50) NOT NULL COMMENT '流程代码',
  `interface_code` varchar(50) NOT NULL COMMENT '接口代码',
  `app_key` varchar(50) DEFAULT NULL COMMENT '应用密钥',
  `request_id` varchar(50) NOT NULL COMMENT '请求ID',
  `status` tinyint(4) DEFAULT '0' COMMENT '执行状态(0:初始化,1:执行中,2:成功,3:失败)',
  `error_message` text COMMENT '错误信息',
  `current_node_id` varchar(50) DEFAULT NULL COMMENT '当前执行节点ID',
  `context_data` longtext COMMENT '上下文数据(JSON格式)',
  `retry_count` int(11) DEFAULT '0' COMMENT '重试次数',
  `max_retry_count` int(11) DEFAULT '3' COMMENT '最大重试次数',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_execution_id` (`execution_id`),
  KEY `idx_process_code` (`process_code`),
  KEY `idx_status_retry` (`status`,`retry_count`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='流程执行记录表';
```

## 5. 流程引擎实现

### 5.1 Node接口

节点是流程引擎的基本执行单元，所有具体节点都需要实现此接口。

```java
public interface Node {
    String inParamName="inParamName";
    String outParamName="outParamName";
    String inParamType="inParamType";
    String outParamType="outParamType";

    String side="side";
    String requestParams="requestParams";
    String NodeConfig="NodeConfig";

    boolean execute(ProcessContext context);
    String getNodeId();
    String getNodeName();
}
```

### 5.2 ProcessContext类

上下文类用于在流程执行过程中传递和存储数据。

```java
@Data
public class ProcessContext {
    // 请求ID
    private String requestId;
    // 接口代码
    private String interfaceCode;
    // AppKey
    private String appKey;
    // 请求参数
    private Map<String, Object> requestParams = new HashMap<>();
    // 响应结果
    private Object responseData;
    // 处理状态
    private boolean success = true;
    // 错误信息
    private String errorMessage;
    // 错误码
    private String errorCode;
    // 中间数据存储
    private Map<String, Object> attributes = new HashMap<>();

    // 其他方法...
}
```

### 5.3 ProcessEngine类

流程引擎的核心实现，负责流程的执行、异步处理和重试逻辑。

```java
@Slf4j
@Component
public class ProcessEngine {
    @Autowired
    private SysProcessNodeConfigService processNodeConfigService;
    @Autowired
    private SysProcessExecutionRecordService processExecutionRecordService;
    @Autowired
    private Map<String, Node> nodeMap;

    // 异步执行线程池
    private final ExecutorService asyncExecutor = new ThreadPoolExecutor(
            10, // 核心线程数
            50, // 最大线程数
            60L, TimeUnit.SECONDS, // 空闲线程存活时间
            new LinkedBlockingQueue<>(1000), // 工作队列
            new ThreadPoolExecutor.CallerRunsPolicy() // 拒绝策略
    );

    // 执行流程方法
    public Result<JSONObject> executeProcess(String processCode, ProcessContext context) {
        // 实现流程执行逻辑
    }

    // 其他方法...
}
```

## 6. 原子节点配置与实现

### 6.1 节点配置示例

节点配置使用JSON格式，主要包含输入输出参数定义和节点特定配置。

```json
{
  "inParamName": "requestParams",
  "inParamType": "map",
  "outParamName": "nationalNodeResponse",
  "outParamType": "jsonObject",
  "retryConfig": {
    "maxRetryCount": 3,
    "initialDelay": 1000,
    "multiplier": 2.0
  }
}
```

### 6.2 全国节点请求节点实现

```java
@Slf4j
@Component("nationalNodeRequestNode")
public class NationalNodeRequestNode implements Node {
    @Autowired
    private NationalNodeConfig nationalNodeConfig;

    private static final String NODE_ID = "nationalNodeRequestNode";
    private static final String NODE_NAME = "全国节点请求节点";

    @Override
    public boolean execute(ProcessContext context) {
        // 实现全国节点请求逻辑
    }

    // 其他方法...
}
```

## 7. 数据可靠性设计

### 7.1 节点重试机制

系统支持配置化的节点重试机制，使用指数退避算法计算重试间隔。

```java
private static class RetryConfig {
    private final int maxRetryCount; // 最大重试次数
    private final int initialDelay; // 初始延迟（毫秒）
    private final double multiplier; // 延迟倍数

    // 计算指定重试次数的延迟时间
    public long getDelayMs(int retryCount) {
        return (long) (initialDelay * Math.pow(multiplier, retryCount - 1));
    }

    // 其他方法...
}
```

### 7.2 流程恢复机制

系统通过定时任务定期恢复失败的流程执行。

```java
@XxlJob("processRecoveryJob")
public ReturnT<String> processRecovery(String param) {
    // 查询需要重试的执行记录
    List<SysProcessExecutionRecordEntity> records = processExecutionRecordService.getRetryableExecutionRecords();
    
    // 并发处理每个需要重试的记录
    for (SysProcessExecutionRecordEntity record : records) {
        executorService.submit(() -> {
            try {
                // 使用ProcessEngine重放流程
                Result<?> result = processEngine.replayProcess(record.getExecutionId());
                
                if (result.isSuccess()) {
                    // 流程恢复成功
                } else {
                    // 标记为需要重试，让下一次定时任务继续尝试
                    processExecutionRecordService.markForRetry(record.getExecutionId(), result.getMessage());
                }
            } catch (Exception e) {
                // 异常处理
            }
        });
    }
    
    // 其他逻辑...
}
```

## 8. 接口编排示例

### 8.1 创建接口流程

以一个典型的省级节点转发接口为例，其处理流程如下：

1. 接收市级节点请求
2. 验证Token
3. 验证签名
4. 调用全国节点服务
5. 解析全国节点响应
6. 返回结果给市级节点

### 8.2 流程配置

在数据库中配置上述流程的节点信息：

| 节点顺序 | 节点ID | 节点名称 | 异步执行 | 重试配置 |
|---------|-------|---------|---------|---------|
| 1 | tokenValidateNode | Token验证节点 | 否 | {"maxRetryCount":3,"initialDelay":1000,"multiplier":2.0} |
| 2 | signatureVerifyNode | 签名验证节点 | 否 | {"maxRetryCount":3,"initialDelay":1000,"multiplier":2.0} |
| 3 | nationalNodeRequestNode | 全国节点请求节点 | 否 | {"maxRetryCount":5,"initialDelay":2000,"multiplier":1.5} |
| 4 | responseParserNode | 响应解析节点 | 否 | {"maxRetryCount":3,"initialDelay":1000,"multiplier":2.0} |

## 9. 核心代码示例

### 9.1 MainController

```java
@Slf4j
@RestController
@RequestMapping("/api")
public class MainController {
    @Autowired
    private SysInterfaceDefinitionService sysInterfaceDefinitionService;
    @Autowired
    private ProcessEngine processEngine;

    // 处理所有接口请求
    @RequestMapping(value = "{code}", method = {RequestMethod.GET, RequestMethod.POST, RequestMethod.PUT, RequestMethod.DELETE})
    public Result<JSONObject> handleRequest(MultipartFile file, @PathVariable String code, HttpServletRequest request, @RequestBody(required = false) Map<String, Object> requestBody) {
        // 1. 获取请求URL和请求方法
        String requestURI = request.getRequestURI();
        String requestMethod = request.getMethod();
        // 2. 从URL中提取接口路径
        String contextPath = request.getContextPath();
        String interfacePath = requestURI.substring(contextPath.length());
        
        // 3. 根据请求路径查询接口定义
        SysInterfaceDefinitionEntity interfaceDefinition = sysInterfaceDefinitionService.findByRequestPath(interfacePath);
        
        // 4. 构建处理上下文
        ProcessContext context = buildProcessContext(request, requestBody, interfaceDefinition.getInterfaceCode(), interfaceDefinition);
        
        // 5. 使用流程引擎执行流程
        Result<JSONObject> result = processEngine.executeProcess(interfaceDefinition.getProcessCode(), context);
        
        return result;
    }

    // 其他方法...
}
```

### 9.2 ProcessEngine流程执行

```java
public Result<JSONObject> executeProcess(String processCode, ProcessContext context) {
    // 创建流程执行记录
    SysProcessExecutionRecordEntity executionRecord = processExecutionRecordService.createExecutionRecord(
            processCode,
            context.getInterfaceCode(),
            context.getAppKey(),
            context.getRequestId()
    );

    try {
        // 标记流程开始执行
        processExecutionRecordService.updateExecutionStatus(
                executionRecord.getExecutionId(),
                1, // 执行中
                null
        );

        // 查询流程节点配置
        List<SysProcessNodeConfigEntity> nodeConfigs = processNodeConfigService.getEnabledNodesByProcessCode(processCode);
        
        // 按顺序执行节点
        for (SysProcessNodeConfigEntity nodeConfig : nodeConfigs) {
            // 执行节点逻辑
            // ...
        }

        // 完成流程执行
        processExecutionRecordService.completeExecution(
                executionRecord.getExecutionId(),
                context.isSuccess() ? 2 : 3, // 2:成功, 3:失败
                context.isSuccess() ? null : context.getErrorMessage()
        );

        return result;
    } catch (Exception e) {
        // 异常处理
    } finally {
        // 记录执行上下文，用于重放
        processExecutionRecordService.recordExecutionContext(
                executionRecord.getExecutionId(),
                context
        );
    }
}
```

## 10. 配置项说明

系统配置主要包括以下几个方面：

### 10.1 全国节点配置

```java
@Setter
@Getter
@Component
public class NationalNodeConfig {
    // 全国节点地址
    @Value("${provincial.node.national-node-url}")
    private String nationalNodeUrl;

    // 全国节点连接超时时间
    @Value("${provincial.node.connect-timeout}")
    private int connectTimeout;

    // 全国节点读取超时时间
    @Value("${provincial.node.read-timeout}")
    private int readTimeout;

    // 全国节点公钥
    private volatile String publicKey;

    // 全国节点令牌
    private volatile String token;

    // 令牌过期时间（秒）
    @Value("${provincial.node.token.expire-time}")
    private int tokenExpireTime;

    // 令牌刷新阈值（秒）
    @Value("${provincial.node.token.refresh-threshold}")
    private int tokenRefreshThreshold;
}
```

## 11. 部署指南

### 11.1 环境要求

- JDK 1.8+ 
- MySQL 5.7+ 
- Redis 5.0+ 
- XXL-Job 2.3.0+ 

### 11.2 部署步骤

1. 准备数据库并导入表结构
2. 配置应用参数（数据库连接、Redis连接、XXL-Job配置等）
3. 构建并部署应用
4. 配置流程和节点信息
5. 启动应用和相关服务

## 12. 扩展指南

### 12.1 添加新节点

1. 创建实现Node接口的新节点类
2. 使用@Component注解注册节点（指定节点ID）
3. 在数据库中配置节点的使用流程

### 12.2 自定义流程

通过配置数据库中的流程节点信息，可以灵活组合不同的节点来创建新的流程，无需修改代码。

## 13. 监控与维护

系统提供了流程执行记录和错误日志，方便监控和排查问题。定时任务会自动尝试恢复失败的流程，确保数据的可靠性。

---
版本: 1.2
更新时间: 2024-04-28